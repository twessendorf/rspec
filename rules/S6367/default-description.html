<div class="paragraph">
<p>In contrast to normal functions, coroutines can suspend and later resume their execution. Depending on the program, the coroutine may resume on a different thread of execution than the one it was started or run previously on.</p>
</div>
<div class="paragraph">
<p>Therefore, the access to the "same" variable with <code>thread_local</code> storage may produce different values as illustrated below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>thread_local std::vector&lt;Task&gt; tasks;
lazy&lt;Thingy&gt; doSomething() {
  // evalutation started on thread t1
  /* .... */
  const std::size_t taskCount = tasks.size(); // value specific to thread t1
  auto result = co_await produceThingy();
  // after co_await, execution resumes on thread t2
  for (std::size_t i = 0; i &lt; taskCount; ++i) {
    tasks[i].evalute(); // access value specific to t2
    // miss some tasks if t1:taskCount.size() &lt; t2:taskCount.size()
    // undefined behavior if t1:taskCount.size() &gt; t2:taskCount.size()
  }
  return result;
}</pre>
</div>
</div>
<div class="paragraph">
<p>This behavior is surprising and unintuitive in comparison to normal functions that are always evaluated on a single thread.
The same issue can happen for the use of different thread-local variables if their values are interconnected
(e.g. one is the address of the buffer, and the other is the number of elements in the buffer).</p>
</div>
<div class="paragraph">
<p>Moreover, access to <code>thread-local</code> variables defined inside the coroutine may read uninitialized memory.
Each such variable is initialized when a specific thread enters the function for the first time,
and if the function was never called from a thread on which the coroutine is resumed, it is uninitialized.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue on the declaration of <code>thread_local</code> variables and access to <code>thread_local</code> variables
in coroutines.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>thread_local std::vector&lt;Task&gt; tasks;
lazy&lt;Thingy&gt; doSomething() {
  thread_local Tasks localTask; // Noncompliant
  const std::size_t taskCount = tasks.size(); // Noncompliant
  /* ... */
  auto result = co_await produceThingy();
  for (std::size_t i = 0; i &lt; taskCount; ++i) {
     tasks[i].evalute(); // Noncompliant
  }
  localTask.evaluate(); // Noncompliant
  return result;
}</pre>
</div>
</div>
</div>
</div>