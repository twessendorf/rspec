<div class="paragraph">
<p><code>for</code>-loops are a very powerful and versatile tool that can be used for many purposes. This flexibility comes with drawbacks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is very easy to make a small mistake when writing them,</p>
</li>
<li>
<p>They are relatively verbose to write,</p>
</li>
<li>
<p>They do not express the intent of the code, the reader has to look at loop details to understand what the loop does.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are algorithms that encapsulate a <code>for</code>-loop and give it some meaning (<code>std::all_of</code>, <code>std::count_if</code>, <code>std::remove_if</code>&#8230;&#8203;). These algorithms are well tested, efficient, and explicit and therefore should be your first choice.</p>
</div>
<div class="paragraph">
<p>This rule detects loops that go through all consecutive elements of a sequence (eg: containers, objects with begin() and end() member functions), and deal only with the current element without side-effects on the rest of the sequence.</p>
</div>
<div class="paragraph">
<p>This rule suggests using one of the supported STL algorithm patterns corresponding to your C&#43;&#43; standard when a loop matches it.</p>
</div>
<div class="paragraph">
<p>Currently, this rule supports:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>std::all_of</code> (since C&#43;&#43;11) and <code>std::ranges::all_of</code> (since C&#43;&#43;20): returns <code>true</code> if all elements in the given range are matching the given predicate, <code>false</code> otherwise</p>
</li>
<li>
<p><code>std::none_of</code> (since C&#43;&#43;11) and <code>std::ranges::none_of</code> (since C&#43;&#43;20): returns <code>true</code> if no elements in the given range are matching the given predicate, <code>false</code> otherwise</p>
</li>
<li>
<p><code>std::any_of</code> (since C&#43;&#43;11) and <code>std::ranges::any_of</code> (since C&#43;&#43;20): returns <code>true</code> if at least one element in the given range is matching the given predicate, <code>false</code> otherwise</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This rule suggests two options below when the loop doesn&#8217;t match any of the supported STL algorithm patterns and you just want to iterate over all elements of a sequence:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Range-based <code>for</code>-loops, which were introduced in C&#43;&#43;11 and will run through all elements of a sequence</p>
</li>
<li>
<p><code>std::for_each</code>, an algorithm that performs the same operation between two iterators (allowing more flexibility, for instance by using <code>reverse_iterator</code>s, or with a variant that can loop in parallel on several elements at a time).</p>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>#include &lt;vector&gt;
#include &lt;iostream&gt;

using namespace std;

bool asDesired(const int v);

bool areAllDesired(std::vector&lt;int&gt; values) {
  for (int val : values) { // Noncompliant, replace it by a call to std::all_of
    if (!asDesired(val)) {
      return false;
    }
  }
  return true;
}

int f(vector&lt;int&gt; &amp;v) {

  for (auto it = v.begin(); it != v.end(); ++it) { // Noncompliant
    if (*it &gt; 0) {
      cout &lt;&lt; "Positive number : " &lt;&lt; *it &lt;&lt; endl;
    } else {
      cout &lt;&lt; "Negative number : " &lt;&lt; *it &lt;&lt; endl;
    }
  }

  auto sum = 0;
  for (auto it = v.begin(); it != v.end(); ++it) { // Noncompliant
    sum += *it;
  }
  return sum;
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

bool asDesired(const int v);

bool areAllDesired2(std::vector&lt;int&gt; values) {
  return std::all_of(std::begin(values), std::end(values), asDesired);
}

bool areAllDesiredCpp20(std::vector&lt;int&gt; values) {
  return std::ranges::all_of(values, asDesired);
}

void displayNumber(int i) {
  if (i &gt; 0) {
    cout &lt;&lt; "Positive number : " &lt;&lt; i &lt;&lt; endl;
  } else {
    cout &lt;&lt; "Negative number : " &lt;&lt; i &lt;&lt; endl;
  }
}

void f(vector&lt;int&gt; &amp;v) {

  std::for_each(v.begin(), v.end(), displayNumber);
  // Or since C++20:
  std::ranges::for_each(v, displayNumber);

  auto sum = 0;
  for (auto elt : v) {
    sum += elt;
  }
  return sum;
  // An even better way to write this would be:
  // return std::accumulate(v.begin(), v.end(), 0);
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see">See</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es71-prefer-a-range-for-statement-to-a-for-statement-when-there-is-a-choice">C&#43;&#43; Core Guidelines ES.71</a> - Prefer a range-for-statement to a for-statement when there is a choice</p>
</li>
<li>
<p><a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#p3-express-intent">C&#43;&#43; Core Guidelines P.3</a> - Express intent</p>
</li>
</ul>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Convert this loop into a range-based for loop</p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_on_5_nov_2019_183054_loïc_joly_wrote">on 5 Nov 2019, 18:30:54 Loïc Joly wrote:</h3>
<div class="paragraph">
<p>\[~amelie.renard]: Can you please review my changes?</p>
</div>
</div>
</div>
</div>