<div class="paragraph">
<p>The memory functions <code>memset</code>, <code>memcpy</code>, <code>memmove</code>, and <code>memcmp</code> take as last argument the number of bytes they will work on. If this size argument is badly defined (eg it is greater than the size of the destination object), it can lead to undefined behavior.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when the size argument of a memory function seems inconsistent with the other arguments of the function.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>struct A {};

void f() {
  struct A dest;
  memset(&amp;dest, 0, sizeof(&amp;dest)); // Noncompliant; size is based on "A*" when the destination is of type "A"
  struct A src;
  memcpy(&amp;dest, &amp;src, sizeof(&amp;dest)); // Noncompliant; size is based on "A*" when the source is of type "A"

  if (memset(&amp;dest, 0, sizeof(dest) != 0)) { // Noncompliant; size argument is a comparison
    // ...
  }
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>struct A {};

void f() {
  struct A dest;
  memset(&amp;dest, 0, sizeof(dest)); // Compliant
  struct A src;
  memcpy(&amp;dest, &amp;src, sizeof(dest)); // Compliant

  if (memset(&amp;dest, 0, sizeof(dest)) != 0) { // Compliant
    // ...
  }
}</pre>
</div>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>"memset" call operates on objects of type XXX while the size is based on a different type</p>
</div>
</div>
</div>
</div>