<div class="paragraph">
<p>Calling methods or fields which are not initialized in constructors or destructors can lead to undefined behavior.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="paragraph">
<p>Calling an overridable member function from a constructor or destructor could result in unexpected behavior when instantiating a subclass which overrides the member function.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By contract, the subclass class constructor starts by calling the parent class constructor.</p>
</li>
<li>
<p>The parent class constructor calls the parent member function and not the one overridden in the child class, which is confusing for child class' developer.</p>
</li>
<li>
<p>It can produce an undefined behavior if the member function is pure <code>virtual</code> in the parent class.</p>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>class Parent {
  public:
    Parent() {
      method1();
      method2(); // Noncompliant; confusing because Parent::method2() will always been called even if the method is overridden
    }
    Parent(int i):field(i) {}
    virtual ~Parent() {
      method3(); // Noncompliant; undefined behavior (ex: throws a "pure virtual method called" exception)
    }
  protected:
    int field;

    int          method1() { /*...*/ }
    virtual void method2() { /*...*/ }
    virtual void method3() = 0; // pure virtual
};

class Child : public Parent {
  public:
    Child() { // leads to a call to Parent::method2(), not Child::method2()
    }
    Child() : Parent(field) {} // Noncompliant; "field" is not initialized yet
    Child() : Parent(method1()) {} // Noncompliant; "method1" is not initialized yet
    virtual ~Child() {
      method3(); // Noncompliant; Child::method3() will always be called even if a child class overrides method3
    }
  protected:
    void method2() override { /*...*/ }
    void method3() override { /*...*/ }
};</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>class Parent {
  public:
    Parent() {
      method1();
      Parent::method2(); // acceptable but poor design
    }
    virtual ~Parent() {
      // call to pure virtual function removed
    }
  protected:
    void         method1() { /*...*/ }
    virtual void method2() { /*...*/ }
    virtual void method3() = 0;
};

class Child : public Parent {
  public:
    Child() {
    }
    virtual ~Child() {
      method3(); // method3() is now final so this is okay
    }
  protected:
    void method2() override { /*...*/ }
    void method3() final    { /*...*/ } // this virtual function is "final"
};</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see">See</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://wiki.sei.cmu.edu/confluence/x/8zZGBQ">CERT, MET05-J.</a> - Ensure that constructors do not call overridable methods</p>
</li>
<li>
<p><a href="https://wiki.sei.cmu.edu/confluence/x/6ns-BQ">CERT, OOP50-CPP.</a> - Do not invoke virtual functions from constructors or destructors</p>
</li>
</ul>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Remove this call from a constructor to the overridable "XXXX" method.</p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_on_15_mar_2016_114940_alban_auzeill_wrote">on 15 Mar 2016, 11:49:40 Alban Auzeill wrote:</h3>
<div class="paragraph">
<p>Add C&#43;&#43; Language-Specification</p>
</div>
</div>
</div>
</div>