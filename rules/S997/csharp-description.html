<div class="paragraph">
<p>Declaring names in appropriate namespaces reduces the number of names found during lookup, decreasing the risk of name clash and of surprising name lookup.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when a name in the global namespace has external linkage and therefore can be accessed from outside a particular translation unit.</p>
</div>
<div class="paragraph">
<p>Some names have to be declared in the global namespace, and are excluded from this rule:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>main</code> (or its variants)</p>
</li>
<li>
<p>Overloads of the global <code>new</code> &amp; <code>delete</code> operators</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition, no issue is raised for function definitions because they can only be accessed from different translation units through a forward declaration that will be flagged.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>int a; // Noncompliant
int b = 1; // Noncompliant
extern int  c = 1; // Noncompliant
extern const int d = 1; // Noncompliant

void f(); // Noncompliant

class A { // Noncompliant
};</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>namespace MY_API { // Compliant
int a;
int b = 1;
extern int  c = 1;
extern const int d = 1;

void  f();

class A {
};
} // namespace MY_API

namespace { // Compliant, anonymous namespace
  int  a = 1;
  void m2() {
  }
}

int main() { // Compliant, exception for main
}

static int a; // Compliant, internal linkage
static void m1(); // Compliant, internal linkage

const int a = 1; // Compliant, a global constant is implicitly static

extern "C" int a = 1; // Compliant

extern "C" void f1(); // Compliant
void f2() {} // Compliant

typedef int a; // Compliant, we don't detect aliases

void *operator new(size_t bytes, const X::Y&amp; context) { return X::malloc(bytes,context); } // Compliant by exception
void operator delete(void* ptr,  const X::Y&amp; context) { X::free(bytes,context); } // Compliant by exception</pre>
</div>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_is_related_to_s3903">is related to: S3903</h3>

</div>
<div class="sect2">
<h3 id="_on_8_apr_2015_131946_massimo_paladin_wrote">on 8 Apr 2015, 13:19:46 Massimo PALADIN wrote:</h3>
<div class="paragraph">
<p>\[~ann.campbell.2] this rspec was empty, I updated it with data from the current implementation, could you please update it to current format?</p>
</div>
</div>
</div>
</div>