<div class="paragraph">
<p>In C, a string is just a buffer of characters, usually using the <code>null</code> character as a sentinel for the end of the string. Which mean that the developer has to be aware of low level details such as buffer sizes, having an extra character to store the final null character&#8230;&#8203; Doing that correctly and consistently is notoriously difficult, and any error can lead to a security vulnerability, for instance giving access to sensitive data, or allowing arbitrary code execution.</p>
</div>
<div class="paragraph">
<p>The function <code>char *strlen(char * restrict s);</code> measures the length of the string <code>s</code> (excluding the final null character). The <code>wcslen</code> does the same for wide characters, and should be used with the same guidelines.</p>
</div>
<div class="sect1">
<h2 id="_ask_yourself_whether">Ask Yourself Whether</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>There is a possibility that the pointer is null</p>
</li>
<li>
<p>There is a possibility that the string is not correctly null-terminated</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is a risk if you answered yes to any of those questions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_recommended_secure_coding_practices">Recommended Secure Coding Practices</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>C11 provides, in its annex K, the <code>strlen_s</code> and the <code>wcslen_s</code> that were designed as safer alternative to <code>strlen</code> and <code>wcslen</code>. It&#8217;s not recommended to use them in all circumstances, because they introduce a runtime overhead and require to write more code for error handling, but they perform checks that will limit the consequences of calling the function with bad arguments.</p>
</li>
<li>
<p>Even if your compiler does not exactly support annex K, you probably have access to similar functions</p>
</li>
<li>
<p>If you are writing C&#43;&#43; code, using <code>std::string</code> to manipulate strings is much simpler and less error-prone</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sensitive_code_example">Sensitive Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>int f(char *src) {
  char dest[256];
  strncpy(dest, src, sizeof dest); // Truncation may happen
  return strlen(dest); // Sensitive: "dest" will not be null-terminated if truncation happened
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>int f(char *src) {
  char dest[256];
  strncpy(dest, src, sizeof dest); // Truncation may happen
  dest[sizeof dest - 1] = 0;
  return strlen(dest); // Compliant: "dest" is guaranteed to be null-terminated
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see">See</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://cwe.mitre.org/data/definitions/120.html">MITRE, CWE-120</a> - Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')</p>
</li>
<li>
<p><a href="https://wiki.sei.cmu.edu/confluence/x/HdcxBQ">CERT, STR07-C.</a> - Use the bounds-checking interfaces for string manipulation</p>
</li>
</ul>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Make sure use of "strlen" is safe here.</p>
</div>
</div>
</div>
</div>