<div class="paragraph">
<p>Failing to release the state of a coroutine results in leaks of the coroutine frame, its parameters, promise object, and, depending on the suspension point, a set of local variables that where preserved on heap.</p>
</div>
<div class="paragraph">
<p>On one hand, the coroutine state is automatically released by the compiler when <code>final_suspend()</code> completes without suspending the coroutine. In other words, the relevant objects are destroyed when the execution flows off the end of the "body" (as rewritten by the compiler) of the coroutine.</p>
</div>
<div class="paragraph">
<p>On the other hand, the coroutine state is manually released when <code>destroy()</code> is invoked on its handle. Note that destroying a running coroutine or one that was already destroyed leads to undefined behavior.</p>
</div>
<div class="paragraph">
<p>This rules raises an issue when a coroutine state is leaked.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class ComplexTask {
  struct promise_type {
    std::suspend_always final_suspend() const noexcept;
    /* ... */
  };
  std::coroutine_handle&lt;&gt; handle;
public:
  Task(std::coroutine_handle&lt;&gt; handle) : handle(handle) { }
};

ComplexTask complexTask(Config data) {
  // At this point, a copy of `data` is created and stored as part of the coroutine state.
  co_return something(data);
}

void doSomeWork() {
  auto task = complexTask(buildConfig());
} // Noncompliant
// The coroutine handle was not released and the copy of `data` is leaked.</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class ComplexTask {
  struct promise_type {
    std::suspend_always final_suspend() const noexcept;
    /* ... */
  };
  std::coroutine_handle&lt;&gt; handle;
public:
  Task(std::coroutine_handle&lt;&gt; handle) : handle(handle) { }
  Task(Task&amp;&amp; other) : handle(std::exchange(other.handle, nullptr)) { }
  ~Task() { if (handle) handle.destroy(); }
};

ComplexTask complexTask(Config data) {
  // At this point, a copy of `data` is created and stored as part of the coroutine state.
  co_return something(data);
}

void doSomeWork() {
  auto task = complexTask(buildConfig());
}
// The copy of `data` is released via ~Task().</code></pre>
</div>
</div>
</div>
</div>