<div class="paragraph">
<p>C&#43;&#43;17 introduced a construct to create and initialize a variable within the condition of <code>if</code> and <code>switch</code> statements and C&#43;&#43;20 added this construct to range-based <code>for</code> loops. Using this new feature simplifies common code patterns and helps in giving variables the right scope.</p>
</div>
<div class="paragraph">
<p>Previously, variables were either declared before the statement, hence leaked into the ambient scope, or an explicit scope was used to keep the scope tight, especially when using RAII objects. This was inconvenient as it would lead to error-prone patterns.</p>
</div>
<div class="paragraph">
<p>For example, this verbose error-prone initialization:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>bool error_prone_init() {
  { // explicit scope
    std::unique_lock&lt;std::mutex&gt; lock(mtx, std::try_to_lock);
    if (lock.owns_lock()) {
       //...
     }
  } // mutex unlock
  // ... code
  return true;
}</pre>
</div>
</div>
<div class="paragraph">
<p>can now be replaced by the following code, which is safer and more readable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>bool better_init() {
  if (std::unique_lock&lt;std::mutex&gt; lock(mtx, std::try_to_lock); lock.owns_lock()) {
     //...
  } // mutex unlock
  // ... code
  return true;
}</pre>
</div>
</div>
<div class="paragraph">
<p>This rule raises an issue when:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a variable is declared just before a statement that allows variable declaration (<code>if</code>, <code>switch</code>, or, starting C&#43;&#43;20, range-based <code>for</code> loop),</p>
</li>
<li>
<p>this variable is used in the statement header,</p>
</li>
<li>
<p>there are other statements after this statement where this variable might be used,</p>
</li>
<li>
<p>yet, it is never used after the statement.</p>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>void handle(std::string_view s);
void ifStatement() {
  std::map&lt;int, std::string&gt; m;
  int key = 1;
  std::string value = "str1";
  auto [it, inserted] = m.try_emplace(key, value); // Noncompliant
  if (!inserted) {
    std::cout &lt;&lt; "Already registered";
  } else {
    handle(it-&gt;second);
  }
  process(m);
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>enum class State { True, False, Maybe, MaybeNot };
std::pair&lt;std::string, State&gt; getStatePair();

void switchStatement() {
  auto state = getStatePair(); // Noncompliant
  switch (state.second) {
    case State::True:
    case State::Maybe:
      std::cout &lt;&lt; state.first;
      break;
    case State::False:
    case State::MaybeNot:
      std::cout &lt;&lt; "No";
      break;
  }
  std::cout &lt;&lt; "\n";
}</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>std::vector&lt;std::vector&lt;int&gt;&gt; getTable();
void printHeadersBad() {
  auto rows = getTable(); // Noncompliant in C++20: rows is accessible outside of the loop
  for (int x : rows[0]) {
    std::cout &lt;&lt; x &lt;&lt;' ';
  }
  std::cout &lt;&lt; "\n";
}</pre>
</div>
</div>
<div class="paragraph">
<p>Using a temporary to avoid leaking of the variable into the ambient scope creates a bigger problem: an undefined behavior. Even though the lifetime of a temporary returned by the range expression is extended, the life of a temporary within the range expression terminates before the loop begins to execute.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>std::vector&lt;std::vector&lt;int&gt;&gt; getTable();
void printHeadersWorse() {
  for (int x : getTable()[0]) { // Undefined behavior: return value of getTable() no longer exists in the loop body
    std::cout &lt;&lt; x &lt;&lt;' ';
  }
  std::cout &lt;&lt; "\n";
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>void handle(std::string_view s);
void ifStatement() {
  std::map&lt;int, std::string&gt; m;
  int key = 1;
  std::string value = "str1";
  if (auto [it, inserted] = m.try_emplace(key, value); !inserted) { // Compliant
    std::cout &lt;&lt; "Already registered";
  } else {
    handle(it-&gt;second);
  }
  process(m);
}

enum class State { True, False, Maybe, MaybeNot };
std::pair&lt;std::string, State&gt; getStatePair();

void switchStatement() {
  switch (auto state = getStatePair(); state.second) { // Compliant
    case State::True:
    case State::Maybe:
      std::cout &lt;&lt; state.first;
      break;
    case State::False:
    case State::MaybeNot:
      std::cout &lt;&lt; "No";
      break;
  }
  std::cout &lt;&lt; "\n";
}

std::vector&lt;std::vector&lt;int&gt;&gt; getTable();
void printHeadersGood() {
  // Compliant: rows is accessible only inside the loop (this code requires at least C++20)
  for (auto rows = getTable(); int x : table[0]) {
    std::cout &lt;&lt; x &lt;&lt;' ';
  }
  std::cout &lt;&lt; "\n";
}</pre>
</div>
</div>
</div>
</div>