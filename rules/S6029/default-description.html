<div class="paragraph">
<p>Starting C&#43;&#43;17, exception specifications became a part of a function type. This implies that these two functions, for example, have different types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>void first() noexcept;
void second();</pre>
</div>
</div>
<div class="paragraph">
<p>Making exception specifications part of the type will, for the right reason, break code where a function that throws an exception is provided in a context where <code>noexcept</code> function is expected.</p>
</div>
<div class="paragraph">
<p>It is important to note that the same way it is not allowed to overload based on the return type, it is also not allowed to overload based on the exception specifications.</p>
</div>
<div class="paragraph">
<p>This rule will trigger on code that will stop compiling starting C&#43;&#43;17, and on explicit casts that add <code>noexcept</code> to a type.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>template&lt;typename T&gt;
void callF1(T t1, T t2) {
  t1();
  t2();
}

void f1();
void f1NoExcept() noexcept;

int main() {
  callF1(f1, f1NoExcept); // Noncompliant, f1 and f1NoExcept have different types
  std::function&lt;void() noexcept&gt; fptr1 = f1; // Noncompliant
  void (*fptr2)() noexcept = f1; // Noncompliant
  void (*fptr3)() noexcept = (void (*)() noexcept) f1; // Noncompliant, it works even in c++17
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>template&lt;typename T1, typename T2&gt;
void callF1(T1 t1, T2 t2) {
  t1();
  t2();
}

void f1();
void f1NoExcept() noexcept;

int main() {
  callF1(f1, f1NoExcept); // Compliant
  std::function&lt;void() noexcept&gt; fptr1 = f1NoExcept; // Compliant
  void (*fptr2)() = f1; // Compliant
}</pre>
</div>
</div>
</div>
</div>