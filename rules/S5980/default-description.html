<div class="paragraph">
<p>Multiple smart pointers should not be initialized with pointers pointing to the same memory. Smart pointers take care of calling the object deleter; this means that two smart pointers initialized with the same raw pointer value would lead to calling the delete function twice on the same address.Â Double deleting is a recipe for undefined behavior.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>void fshared_ptr() {
  int* p = new int;
  std::shared_ptr&lt;int&gt; p1(p);
  std::shared_ptr&lt;int&gt; p2(p); // Noncompliant, memory deleted twice
}

void funique_ptr(int* p1) {
  std::unique_ptr&lt;int&gt; p2(p1); // Noncompliant, memory deleted twice
}

void f() {
  auto up = std::make_unique&lt;int&gt;(10);
  funique_ptr(up.get());
}</pre>
</div>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Review these "shared_ptr"/"unique_ptr" initializations.</p>
</div>
</div>
<div class="sect2">
<h3 id="_highlighting">Highlighting</h3>
<div class="paragraph">
<p>Primary location: The first "shared_ptr"/"unique_ptr"</p>
</div>
<div class="paragraph">
<p>Secondary locations: The others "shared_ptr"/"unique_ptr"</p>
</div>
</div>
</div>
</div>