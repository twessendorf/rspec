<div class="paragraph">
<p>When you are using lambdas in a member function, you can capture <code>this</code> implicitly through <code>[=]</code> or <code>[&amp;]</code> or explicitly through <code>[this]</code>. This will capture the current object pointer by reference or by value, but the underlying object will always be captured by reference (see S5019).</p>
</div>
<div class="paragraph">
<p>This will become a problem:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the lifetime of the lambda exceeds the one of the current object.</p>
</li>
<li>
<p>When you want to capture the current state of the object.</p>
</li>
<li>
<p>When you want to pass a copy of the object to avoid any concurrency issue.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>C&#43;&#43;14</code> provides a workaround to solve this problem. Where you can take the underlying object by copy using the following pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>auto lam = [copyOfThis = *this] { std::cout &lt;&lt; copyOfThis.field; };</pre>
</div>
</div>
<div class="paragraph">
<p>This is verbose and error-prone, as you might implicitly not use the copied object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>auto lam = [&amp; , copyOfThis = *this] {
std::cout &lt;&lt; field; // implicitly calling “this” captured by reference
};</pre>
</div>
</div>
<div class="paragraph">
<p><code>C&#43;&#43;17</code> solves this problem by introducing an explicit consistent way to capture <code>this</code> by copy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>auto lam = [&amp;, *this] {
std::cout &lt;&lt; field // implicitly calling “this” captured by copy
};</pre>
</div>
</div>
<div class="paragraph">
<p>This rule will flag the <code>C&#43;&#43;14</code> way of capturing the current object by copy and suggest to replace it with the <code>C&#43;&#43;17</code> way.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>struct A {
  int field = 0;
  void memfn() const {
    auto lam = [copyOfThis = *this] { // Noncompliant
      std::cout &lt;&lt; copyOfThis.field;
    };
  }
};</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>struct A {
  int field = 0;
  void memfn() const {
    auto lam = [*this] { // Compliant
      std::cout &lt;&lt; field;
    };
  }
};</pre>
</div>
</div>
</div>
</div>