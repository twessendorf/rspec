<div class="paragraph">
<p>Slicing is what happens when an object from a derived type is cast to an object of one of its base classes. When this happens, the newly created object will not have any of the member variables that are specific to the derived type. This is usually not what was intended. Most of the time, polymorphism is achieved by casting a reference or a pointer to an object of the derived class to a reference or a pointer to an object of a base class.</p>
</div>
<div class="paragraph">
<p>Note that it&#8217;s usually a good idea to design a base class so that slicing cannot happen (it can be <em>abstract</em>, or <em>non-copiable</em>).</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>struct Shape {
  Point position;
  virtual ~Shape() = default;
};
struct Circle : public Shape {
  double radius;
};

void f() {
  vector&lt;Shape&gt; myShapes;
  Circle c;
  myShapes.push_back(c); // Noncompliant. What will be in the vector is a Shape, not a Circle, and won't contain any radius
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>void f() {
  vector&lt;unique_ptr&lt;Shape&gt;&gt; myShapes;
  auto c = make_unique&lt;Circle&gt;();
  myShapes.push_back(move(c)); // Compliant. A pointer to Shape that happens to point to a Circle
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see">See</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es63-dont-slice">C&#43;&#43; Core Guidelines ES.63</a> - Donâ€™t slice</p>
</li>
</ul>
</div>
</div>
</div>