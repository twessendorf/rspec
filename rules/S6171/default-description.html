<div class="paragraph">
<p>C&#43;&#43;20 introduces the member function <code>contains</code> on associative containers to check if an equivalent to a specific key already exists in the container.</p>
</div>
<div class="paragraph">
<p>Calling this function can replace previous ways to check if a key is present in a container:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>call <code>find()</code> and check that its result is not the end of the container. This was quite verbose.</p>
</li>
<li>
<p>call <code>count()</code>. This did not clearly express the intent, and was not optimal in terms of performances for containers that allow a key to be present multiple times.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This rule raises an issue when “contains” could be used to simplify the code.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>void f1(std::set&lt;int&gt; &amp;s) {
  if (s.find(1) == s.end()) { // Noncompliant
      doSomething();
  }
}

void f2(std::unordered_map&lt;std::string, int&gt; &amp;m) {
  if (m.count("key") != 0) { // Noncompliant
      doSomething();
  }
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>void f1(std::set&lt;int&gt; &amp;s) {
  if (!s.contains(1)) { // Compliant
      doSomething();
  }
}

void f2(std::unordered_map&lt;std::string, int&gt; &amp;m) {
  if (m.contains("key")) { // Compliant
      doSomething();
  }
}</pre>
</div>
</div>
</div>
</div>