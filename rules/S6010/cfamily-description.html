<div class="paragraph">
<p>Since C&#43;&#43;17, the class <code>std::filesystem::path</code> can be used to store a file path. Compared to a regular string, it offers several advantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Having a dedicated type makes the intention clear</p>
</li>
<li>
<p>This class stores the path with an encoding that is appropriate to the OS where the program runs</p>
</li>
<li>
<p>It provides several functions that make it more convenient to manipulate than a <code>string</code> (for instance <code>operator/</code> for concatenations)</p>
</li>
<li>
<p>It provides a normalized way to specify the path, easing the portability of the code (on Windows and Linux, the native way is equivalent to the normalized way, which reduces overhead).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This rule raises an issue when the same <code>string</code> is converted several times to a <code>path</code> because it indicates that a single path object could have been used in all occurrences. Additionally, it can also be more efficient, since a conversion from <code>string</code> to <code>path</code> may require a change of encoding and a memory allocation.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>std::string getUserData();
namespace fs = std::filesystem;
void f() {
  std::string const filePath = getUserData();
  if (fs::exists(filePath)) {
    logTime(fs::last_write_time(filePath)); // Noncompliant
  }
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>std::string getUserData();
namespace fs = std::filesystem;
void f() {
  fs::path const filePath = getUserData();
  if (fs::exists(filePath) {
    logTime(fs::last_write_time(filePath)); // Compliant
  }
}</pre>
</div>
</div>
</div>
</div>