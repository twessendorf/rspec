<div class="paragraph">
<p>To configure an algorithm with a function in C&#43;&#43;,  you can use one of the following techniques:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A function pointer (see S5205 that explains why it is a bad idea)</p>
</li>
<li>
<p>An <code>std::function</code></p>
</li>
<li>
<p>A template argument</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>How do you select between an <code>std::function</code> and a template argument?</p>
</div>
<div class="paragraph">
<p><code>std::function</code> offers the most flexibility. You can store them in a variable, in a container (as <code>std::map&lt;string, std::function&lt;void(void)&gt;&gt;</code> for instance&#8230;&#8203; This flexibility is provided by type erasure: A single <code>std::function</code> can wrap any kind of functor, as long as the signature is compatible. It also comes with a cost: Due to this type erasure, a compiler will typically not be able to inline a call to a <code>std::function</code>.</p>
</div>
<div class="paragraph">
<p>Template parameters, on the other hand, are less flexible. Each functor has its own type, which prevents storing several of them together even if they all have compatible signatures. But since each template instance knows the type of the functor, calls can be inlined making this a zero-cost abstraction.</p>
</div>
<div class="paragraph">
<p>As a conclusion, if the functor can be known at compile-time, you should prefer using a template parameter, if it has to be dynamic, <code>std::function</code> will give you greater flexibility.</p>
</div>
<div class="paragraph">
<p>This rule detects function parameters of type <code>std::function</code> that would probably benefit from being replaced by a template parameter. It does so by looking if the functor is only called inside the function, or if it participates in other operations.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>using Criterion = std::function&lt;bool(DataPoint const&amp;)&gt;;
void filter(DataSet* data, Criterion criterion) { // Noncompliant
  for (auto &amp;dataPoint : data) {
    if (criterion(dataPoint)) {
      data.markForRemoval(dataPoint);
    }
  }
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>template&lt;class Criterion&gt;
void filter(DataSet* data, Criterion criterion) { // Compliant
  for (auto &amp;dataPoint : data) {
    if (criterion(dataPoint)) {
      data.markForRemoval(dataPoint);
    }
  }
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exceptions">Exceptions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This rule ignores virtual functions, that don&#8217;t work well with templates.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see">See</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#t49-where-possible-avoid-type-erasure">C&#43;&#43; Core Guidelines T.49</a> - Where possible, avoid type-erasure</p>
</li>
</ul>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Replace this "std::function" by a template parameter.</p>
</div>
</div>
</div>
</div>