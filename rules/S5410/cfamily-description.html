<div class="paragraph">
<p><em>Pointer arithmetic</em> is a way of calculating the address of objects in memory, especially in arrays.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>It features operators ``{plus}{plus}+``, ``++---++``, ``++--=++``, ``{plus}{plus}=`` and subscript operator ``++[]++``.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Pointer arithmetic relies on the type of the pointer to calculate the actual address in memory.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Using the wrong type to do pointer arithmetic leads to wrong result and can corrupt memory.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>``++static_cast++`` can be used to change the type of a pointer. As a result, doing arithmetic on its return value would result in wrong arithmetic.</pre>
</div>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>#include&lt;iostream&gt;

using namespace std;

struct Base {
  int iBase = 0;
};

struct Derived : public Base {
  int iDerived = 0;
};

int main() {
  const size_t size = 4;
  Derived derivedArray[size];
  Base* basePointer = static_cast&lt;Base*&gt;(derivedArray);
  for(int i=0; i&lt;size; ++i) {
    derivedArray[i].iBase = i;                                           // store : 0 1 2 3
    derivedArray[i].iDerived = i*1000;
  }
  for(int i=0; i&lt;size; ++i) {
    cout&lt;&lt;"derivedArray["&lt;&lt;i&lt;&lt;"].iBase="&lt;&lt;derivedArray[i].iBase&lt;&lt;endl;   // display : 0 1 2 3
    cout&lt;&lt;"basePointer["&lt;&lt;i&lt;&lt;"].iBase="&lt;&lt;basePointer[i].iBase&lt;&lt;endl;     // display : 0 0 1 1000
  }
  return 0;
}</pre>
</div>
</div>
<div class="paragraph">
<p>Pointer arithmetic should carried on with the initial pointer type and then the static cast should be applied.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>#include&lt;iostream&gt;

using namespace std;

struct Base {
  int iBase = 0;
};

struct Derived : public Base {
  int iDerived = 0;
};

int main() {
  const size_t size = 4;
  Derived derivedArray[size];
  for(int i=0; i&lt;size; ++i) {
    derivedArray[i].iBase = i;                                           // store : 0 1 2 3
    derivedArray[i].iDerived = i*1000;
  }
  for(int i=0; i&lt;size; ++i) {
    cout&lt;&lt;"derivedArray["&lt;&lt;i&lt;&lt;"].iBase="&lt;&lt;derivedArray[i].iBase&lt;&lt;endl;   // display : 0 1 2 3
    cout&lt;&lt;"base of derivedArray["&lt;&lt;i&lt;&lt;"].iBase="&lt;&lt;static_cast&lt;Base*&gt;(derivedArray+i)-&gt;iBase&lt;&lt;endl;     // display : 0 1 2 3
  }
  return 0;
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exceptions">Exceptions</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>void*</code> is a special type of pointer as it is not typed. It is usually used in some complex schemes. This rule does not apply for a <code>static_cast</code> from a <code>void*</code>.</p>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_is_related_to_s938">is related to: S938</h3>

</div>
<div class="sect2">
<h3 id="_is_related_to_s941">is related to: S941</h3>

</div>
<div class="sect2">
<h3 id="_is_related_to_s942">is related to: S942</h3>

</div>
<div class="sect2">
<h3 id="_is_related_to_s5405">is related to: S5405</h3>

</div>
<div class="sect2">
<h3 id="_on_24_oct_2019_213313_loïc_joly_wrote">on 24 Oct 2019, 21:33:13 Loïc Joly wrote:</h3>
<div class="paragraph">
<p>\[~geoffray.adde] I don&#8217;t think the rule as formulated covers the case of array decay described in PP core guidelines that is, IMO, the most common one&#8230;&#8203;</p>
</div>
</div>
</div>
</div>