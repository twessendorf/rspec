<div class="paragraph">
<p>One of the use cases for the coroutines is suspending execution until certain conditions are satisfied.
In some situations, it is possible that the conditions are already satisfied at the point of the await and the execution can be resumed immediately.</p>
</div>
<div class="paragraph">
<p>The C&#43;&#43; standard provides an efficient method to conditionally suspend the coroutine.
Firstly, the result of <code>await_ready</code> is used to determine whether a coroutine should be suspended. Returning <code>true</code> from this function, when conditions are satisfied,
avoids the cost of the coroutine suspension.
Furthermore, the <code>bool</code>-returning version of <code>await_suspend</code> allows immediate resumption of the current coroutine in the case when <code>false</code> is returned
(returning <code>true</code> indicates that the coroutine should remain suspended).
Compared to symmetric transfer, this method provides better optimization opportunities, as the continuation code is known to the compiler - i.e.
the code of the current coroutine is invoked, while the returned handle could point to an arbitral coroutine.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue on <code>await_suspend</code> that can benefit from using conditional suspension.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>struct WaitForAwaiter {
  Event&amp; event;
  /* .... */
  void await_suspend(std::coroutine_handle&lt;&gt; current) { // Noncompliant
    if (bool ready = event.register_callback(current)) {
      return current;
    } else {
      return std::noop_coroutine();
    }
  }
}

struct ReadBytesAwaiter {
  Socket&amp; socket;
  std::size_t count;
  std::span&lt;std::byte&gt; buffer;
  std::error_code error;
  /* .... */
  void await_suspend(std::coroutine_handle&lt;&gt; current) { // Noncompliant
    auto callback = [&amp;error_store=error, current](std::error_code ec) {
      error_store = ec;
      current.resume();
    };

    auto ec = socket.async_read(buffer, count, callback);
    if (!ec) {
      error = ec;
      current.resume();
    }
  }
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>struct WaitForAwaiter {
  Event&amp; event;
  /* .... */
  bool await_ready() const {
    return event.is_ready();
  }
  bool await_suspend(std::coroutine_handle&lt;&gt; current) {
    return !event.register_callback(current));
  }
}

struct ReadBytesAwaiter {
  Socket&amp; socket;
  std::size_t count;
  std::span&lt;std::byte&gt; buffer;
  std::error_code error;
  /* .... */

  bool await_ready() const {
    return false; // no way to query before suspension
  }
  void await_suspend(std::coroutine_handle&lt;&gt; current) {
    auto callback = [&amp;error_store=error, current](std::error_code ec) {
      error_store = ec;
      current.resume();
    };

    auto ec = socket.async_read(buffer, count, callback);
    if (!ec) {
      error = ec;
      return false;
    }

    return true;
  }
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see">See</h2>
<div class="sectionbody">
<div class="paragraph">
<p>S6365 - transfering execution to any suspended coroutine</p>
</div>
</div>
</div>