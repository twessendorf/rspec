<div class="paragraph">
<p><code>C&#43;&#43;17</code> introduced inline variables. They provide a proper way to define global variables in header files. Before inline variables, it wasn’t possible to simply define global variables without compile or link errors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>struct A {
  static std::string s1 = "s1"; // doesn’t compile
  static std::string s2;
};

A::s2 = "s2"; // doesn’t link, violates the one definition rule
std::string s3 = "s3"; // doesn’t link, violates the one definition rule</pre>
</div>
</div>
<div class="paragraph">
<p>Instead, you had to resort to less readable inconvenient workarounds like variable templates or functions that return a static object. These workarounds will initialize the variables when used instead of the start of the program, which might be inconvenient depending on the program.</p>
</div>
<div class="paragraph">
<p>This rule will detect these workarounds and suggest using inline variables instead.</p>
</div>
<div class="paragraph">
<p>Note that <code>constexpr</code> variables are implicitly <code>inline</code>, so you do not have to explicitly declare them as such (see S5408).</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>struct A {
  static std::string&amp; getS1() { // Noncompliant
    static std::string s1 = "s1";
    return s1;
  }
};

inline std::string&amp; gets2() { // Noncompliant
  static std::string s2 = "s2";
  return s2;
}

template &lt;typename T = std::string&gt;
T s3 = "s3"; // Noncompliant. Available starting C++14</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>struct A {
  inline static std::string s1 = "s1"; // Compliant
};

inline std::string s2 = "s2"; // Compliant</pre>
</div>
</div>
</div>
</div>