<div class="paragraph">
<p>Since C&#43;&#43;17, class template arguments can be automatically deduced by the compiler, either by looking at the arguments of the class constructors or by using an explicitly defined deduction guide.</p>
</div>
<div class="paragraph">
<p>Using the class template argument deduction allow to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Avoid verbose specification of all template parameter types for a class template.</p>
</li>
<li>
<p>Avoid writing helper function that only serves the purpose of deducing the type of a class from its arguments. For example, <code>std::make_pair</code>.</p>
</li>
<li>
<p>Be able to instantiate a class template with hard to spell or unutterable names, such as the closure type of a lambda.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This rule raises an issue when explicit class template arguments that can be automatically deduced is specified.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>void f() {
    std::vector&lt;int&gt; v1 {1, 2, 3}; // Noncompliant, int could have been deduced
}{code}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>using namespace std::literals;
void f() {
    std::vector v1 {1, 2, 3}; // Compliant, int could be deduced
    std::vector&lt;std::string&gt; v2 {"a", "b", "c"}; // Compliant, automatic deduction would create a vector&lt;char const *&gt;
    std::vector v3 {"a"s, "b"s, "c"s}; // Still compliant, another option
}</pre>
</div>
</div>
</div>
</div>