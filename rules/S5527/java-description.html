<div class="paragraph">
<p>To establish a SSL/TLS connection not vulnerable to man-in-the-middle attacks, it&#8217;s essential to make sure the server presents the right certificate.</p>
</div>
<div class="paragraph">
<p>The certificate&#8217;s hostname-specific data should match the server hostname.</p>
</div>
<div class="paragraph">
<p>It&#8217;s not recommended to re-invent the wheel by implementing custom hostname verification.</p>
</div>
<div class="paragraph">
<p>TLS/SSL libraries provide built-in hostname verification functions that should be used.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>HostnameVerifier.verify()</code> method always returns <code>true</code></p>
</li>
<li>
<p>a JavaMail&#8217;s <code>javax.mail.Session</code> is created with a <code>Properties</code> object having no <code>mail.smtp.ssl.checkserveridentity</code> or <code>mail.smtps.ssl.checkserveridentity</code> not configured to <code>true</code></p>
</li>
<li>
<p>a Apache Common Emails&#8217;s <code>org.apache.commons.mail.SimpleEmail</code> is used with <code>setSSLOnConnect(true)</code> or <code>setStartTLSEnabled(true)</code> or <code>setStartTLSRequired(true)</code> without a call to <code>setSSLCheckServerIdentity(true)</code></p>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>URL url = new URL("https://example.org/");
HttpsURLConnection urlConnection = (HttpsURLConnection)url.openConnection();
urlConnection.setHostnameVerifier(new HostnameVerifier() {
  @Override
  public boolean verify(String requestedHost, SSLSession remoteServerSession) {
    return true;  // Noncompliant
  }
});
InputStream in = urlConnection.getInputStream();</pre>
</div>
</div>
<div class="paragraph">
<p>SimpleEmail example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Email email = new SimpleEmail();
email.setSmtpPort(465);
email.setAuthenticator(new DefaultAuthenticator(username, password));
email.setSSLOnConnect(true); // Noncompliant; setSSLCheckServerIdentity(true) should also be called before sending the email
email.send();</pre>
</div>
</div>
<div class="paragraph">
<p>JavaMail&#8217;s example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Properties props = new Properties();
props.put("mail.smtp.host", "smtp.gmail.com");
props.put("mail.smtp.socketFactory.port", "465");
props.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory"); // Noncompliant; Session is created without having "mail.smtp.ssl.checkserveridentity" set to true
props.put("mail.smtp.auth", "true");
props.put("mail.smtp.port", "465");
Session session = Session.getDefaultInstance(props, new javax.mail.Authenticator() {
  protected PasswordAuthentication getPasswordAuthentication() {
    return new PasswordAuthentication("username@gmail.com", "password");
  }
});</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>URL url = new URL("https://example.org/");
HttpsURLConnection urlConnection = (HttpsURLConnection)url.openConnection();
// Compliant; Use the default HostnameVerifier
InputStream in = urlConnection.getInputStream();</pre>
</div>
</div>
<div class="paragraph">
<p>SimpleEmail example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Email email = new SimpleEmail();
email.setSmtpPort(465);
email.setAuthenticator(new DefaultAuthenticator(username, password));
email.setSSLOnConnect(true);
email.setSSLCheckServerIdentity(true); // Compliant
email.send();</pre>
</div>
</div>
<div class="paragraph">
<p>JavaMail&#8217;s example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Properties props = new Properties();
props.put("mail.smtp.host", "smtp.gmail.com");
props.put("mail.smtp.socketFactory.port", "465");
props.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory");
props.put("mail.smtp.auth", "true");
props.put("mail.smtp.port", "465");
props.put("mail.smtp.ssl.checkserveridentity", true); // Compliant
Session session = Session.getDefaultInstance(props, new javax.mail.Authenticator() {
  protected PasswordAuthentication getPasswordAuthentication() {
    return new PasswordAuthentication("username@gmail.com", "password");
  }
});</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see">See</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://owasp.org/Top10/A02_2021-Cryptographic_Failures/">OWASP Top 10 2021 Category A2</a> - Cryptographic Failures</p>
</li>
<li>
<p><a href="https://owasp.org/Top10/A05_2021-Security_Misconfiguration/">OWASP Top 10 2021 Category A5</a> - Security Misconfiguration</p>
</li>
<li>
<p><a href="https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/">OWASP Top 10 2021 Category A7</a> - Identification and Authentication Failures</p>
</li>
<li>
<p><a href="https://www.owasp.org/index.php/Top_10-2017_A6-Security_Misconfiguration">OWASP Top 10 2017 Category A6</a> - Security Misconfiguration</p>
</li>
<li>
<p><a href="https://cwe.mitre.org/data/definitions/295.html">MITRE, CWE-295</a> - Improper Certificate Validation</p>
</li>
<li>
<p>Derived from FindSecBugs rule <a href="https://find-sec-bugs.github.io/bugs.htm#WEAK_HOSTNAME_VERIFIER">WEAK_HOSTNAME_VERIFIER</a></p>
</li>
</ul>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Enable server hostname verification on this SSL/TLS connection</p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_deprecates_s3510">deprecates: S3510</h3>

</div>
<div class="sect2">
<h3 id="_deprecates_s4499">deprecates: S4499</h3>

</div>
<div class="sect2">
<h3 id="_deprecates_s5326">deprecates: S5326</h3>

</div>
<div class="sect2">
<h3 id="_is_related_to_s4830">is related to: S4830</h3>

</div>
<div class="sect2">
<h3 id="_on_5_nov_2020_113949_pierre_loup_tristant_wrote">on 5 Nov 2020, 11:39:49 Pierre-Loup Tristant wrote:</h3>
<div class="paragraph">
<p>.NET API offers <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.security.remotecertificatevalidationcallback">a single callback</a> to override TLS certificates chain and hostname validation. RSPEC-4830 already detects that this callback always accept the server certificate without validation. There is no easy way to detects code that validates the certificate chain and fails to validate the server hostname in this callback.</p>
</div>
<div class="paragraph">
<p>Therefore, this will not be implemented for .NET langauges.</p>
</div>
</div>
</div>
</div>