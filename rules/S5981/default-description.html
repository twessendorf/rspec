<div class="paragraph">
<p>Casting a base-class pointer/reference to a derived-class pointer/reference is commonly referred to as downcasting which can only be done using an explicit cast.</p>
</div>
<div class="paragraph">
<p>However, the use of <code>static_cast</code> for such a cast is unsafe because it doesn&#8217;t do any runtime check.  If the cast memory doesn&#8217;t contain an object of the expected derived type, your program enters the undefined behavior territory.</p>
</div>
<div class="paragraph">
<p>If your object is polymorphic, you might prefer using <code>dynamic_cast</code> instead, as it allows safe downcasting by performing a run-time check:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the cast memory contains an object of the expected derived type, the check succeeds. The result of the <code>dynamic_cast</code> points/refers to the derived object.</p>
</li>
<li>
<p>If the cast memory doesn&#8217;t contain an object of the expected derived type, the check fails. If the <code>dynamic_cast</code> is used on a pointer, <code>nullptr</code> is returned. If it was used on a reference, <code>std::bad_cast</code> is thrown.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This rule raises an issue when <code>static_cast</code> is used for downcasting.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>struct Shape {
  virtual ~Shape();
  // ...
};

struct Rectangle : public Shape {
  double width;
  double height;
};

struct Circle : public Shape {
  double radius;
};

double computeArea(const Shape* shape) {
  const auto* rectangle = static_cast&lt;const Rectangle*&gt;(shape); // Noncompliant
  return rectangle-&gt;width * rectangle-&gt;height;
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>struct Shape {
  virtual ~Shape();
  // ...
};

struct Rectangle : public Shape {
  double width;
  double height;
};

struct Circle : public Shape {
  int radius;
};

double computeArea(const Shape* shape) {
  if(const auto* rectangle = dynamic_cast&lt;const Rectangle*&gt;(shape)) { // Compliant
    return rectangle-&gt;width * rectangle-&gt;height;
  }
  return 0;
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see">See</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/isocpp/CppCoreGuidelines/blob/c553535fb8dda2839d13ab5f807ffbc66b63d67b/CppCoreGuidelines.md#type2-dont-use-static_cast-downcasts-use-dynamic_cast-instead">C&#43;&#43; Core Guidelines - Type safety profile - Type.2</a>: Don’t use static_cast to downcast. Use dynamic_cast instead.</p>
</li>
</ul>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_relates_to_s5823">relates to: S5823</h3>

</div>
</div>
</div>