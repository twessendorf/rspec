<div class="paragraph">
<p>Usually, when copying an object, the source object is unchanged, which means that all resources owned by the source objects have to be duplicated during the copy operation. In the case that the source object will no longer be used, this duplication is not efficient. Since C&#43;&#43;11, a mechanism named move semantic has been added to detect such cases and replace the expensive copy by a much cheaper move operation that will steal resources.</p>
</div>
<div class="paragraph">
<p>The cornerstone of move semantic is the ability to detect during a "copy" if the source object will be reused or not. There are three situations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The object is a temporary object, with no name, and if it can&#8217;t be named, it can&#8217;t be used</p>
</li>
<li>
<p>The object is used in some specific places, such as a return statement</p>
</li>
<li>
<p>The user explicitly promises to the compiler that he won&#8217;t care for the current value of the object any longer. He does so by using the specific cast operation named <code>std::move</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the user write <code>std::move</code> in one situation that is already handled by the first two cases, it has two drawbacks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is clumsy, useless code, which make understanding the code more complex</p>
</li>
<li>
<p>In some cases, it can decrease performances, because this can deactivate another optimization of the compiler, named copy elision.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When copy elision occurs, the object is neither copied nor moved (even if the copy/move constructors have side effects), in fact, the two objects are collapsed into only one memory location. When copy elision occurs is compiler-dependent, but is mandatory in the following cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>in a return statement if the returned object is a prvalue of the same class type as the function return type</p>
</li>
<li>
<p>in the initialization of a variable if the initializer expression is a prvalue of the same class type as the variable type</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This rule reports an issue when the use of <code>std::move</code> prevents the copy elision from happening.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>class A {};
A getA();

A f() {
  A a = std::move(getA()); // Noncompliant, prevents copy elision
  vector&lt;A&gt; v;
  v.push_back(std::move(getA())); // Noncompliant
  return std::move(a); // Noncompliant, prevents copy elision
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>class A {};
void test(A a);

A f() {
  A a = getA(); // Compliant
  vector&lt;A&gt; v;
  v.push_back(getA()); // Compliant
  return a; // Compliant
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see">See</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#i4-make-interfaces-precisely-and-strongly-typed">C&#43;&#43; Core Guidelines I.4</a>: Don’t return std::move(local)</p>
</li>
</ul>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Moving a temporary object prevents copy elision.</p>
</div>
<div class="paragraph">
<p>Moving a temporary object is useless.</p>
</div>
<hr/>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_is_duplicated_by_s5412">is duplicated by: S5412</h3>

</div>
<div class="sect2">
<h3 id="_is_related_to_s5415">is related to: S5415</h3>

</div>
<div class="sect2">
<h3 id="_on_3_sep_2019_180127_loïc_joly_wrote">on 3 Sep 2019, 18:01:27 Loïc Joly wrote:</h3>
<div class="paragraph">
<p>\[~geoffray.adde]: Could you please review the changed I made to this RSPEC?</p>
</div>
</div>
</div>
</div>