<div class="paragraph">
<p><code>auto</code>Â is a type placeholder that may be used in variable declarations to instruct the compiler to infer the type from the initializer.</p>
</div>
<div class="paragraph">
<p>The use of <code>auto</code> reduces unnecessary boilerplate in the situation when the type of the variable is apparent from the context. However, outside of some obvious situations (e.g. when type is spelled in the initializer), the judgment is hard to make. Usually, it is trying to balance between the verbosity of type and the readability from the contributor&#8217;s perspective.</p>
</div>
<div class="paragraph">
<p>Arguably, in the case of the variables initialized from a function that conventionally returns an iterator (e.g. <code>begin</code>, <code>end</code>, <code>std::find</code>), it is clear that the type of the variable is some iterator. Spelling the exact type of the iterator in such a situation does not improve the clarity of the code, especially considering their usual verbosity.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue on the declaration of a variable with an explicit iterator type. and that is initialized from call to a function that conventionally returns an iterator:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>begin</code> and <code>end</code> functions and their const and reverse variants</p>
</li>
<li>
<p>standard algorithms that return iterators</p>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>#include &lt;vector&gt;
#include &lt;map&gt;

std::vector&lt;int&gt;::iterator someFunction(std::vector&lt;int&gt;&amp; v);

void f() {
  std::vector&lt;int&gt; v;
  const std::vector&lt;int&gt;&amp; cv = v;
  std::vector&lt;int&gt;::iterator it1 = v.begin(); // Noncomplaint
  std::vector&lt;int&gt;::const_iterator it2 = v.begin(); // Complaint
  std::vector&lt;int&gt;::const_iterator it3 = v.cbegin(); // Noncomplaint
  std::vector&lt;int&gt;::const_iterator it4 = cv.cbegin(); // Noncomplaint
  std::vector&lt;int&gt;::const_iterator it5 = std::begin(cv); // Noncomplaint

  std::vector&lt;int&gt;::iterator it6 = std::find(v.begin(), v.end(), 10);  // Noncomplaint
  std::vector&lt;int&gt;::iterator it7 = someFunction(10);  // Complaint

   std::map&lt;int, string&gt; m;
   if (std::map&lt;int, string&gt;::iterator it = m.find(20); it != m.end()) { // Noncomplaint
      // do something
  }
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>/* ... */

void f() {
  std::vector&lt;int&gt; v;
  const std::vector&lt;int&gt;&amp; cv = v;
  auto it1 = v.begin();
  std::vector&lt;int&gt;::const_iterator it2 = v.begin();
  auto it3 = v.cbegin();
  auto it4 = cv.cbegin();
  auto it5 = std::begin(cv);

  auto it6 = std::find(v.begin(), v.end(), 10);
  std::vector&lt;int&gt;::iterator it7 = someFunction(10);

   std::map&lt;int, string&gt; m;
   if (auto it = m.find(20); it != m.end()) {
      // do something
  }
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see">See</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>S5827 - use auto to avoid repetition of types</p>
</li>
</ul>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_relates_to_s5827">relates to: S5827</h3>

</div>
</div>
</div>