<div class="paragraph">
<p><code>std::enable_if</code> is a very important part of template meta-programming in C&#43;&#43; up to C&#43;&#43;17. Based on SFINAE, it can be used to subtly tune the behavior of overload resolution based on properties of types.</p>
</div>
<div class="paragraph">
<p>However, using <code>std::enable_if</code> correctly is not easy, and requires skills and experience, for a resulting code that is not straightforward. Since C&#43;&#43;20, new features offer first-class support for what used to require <code>enable_if</code> trickery:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Concepts allow defining named constraints on types, using a terse syntax to specify that a template argument must adhere to a concept;</p>
</li>
<li>
<p><code>requires</code> clauses can be directly written for one-shot constraints;</p>
</li>
<li>
<p>In some cases, using <code>if constexpr</code> (introduced in C&#43;&#43;17) may replace an overload set with just one function (see S6017).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, since those features provide a higher level of abstraction, compilers understand them better and can provide clearer diagnostics when a constraint is violated.</p>
</div>
<div class="paragraph">
<p>As a consequence, <code>std::enable_if</code> is no longer the right tool and should be replaced with those facilities. Note that the replacement is not always mechanical: The expression controlling a <code>std::enable_if</code> would probably be acceptable as a <code>requires</code> condition, but better alternatives usually exist, for instance reusing an existing concept defined in the standard.</p>
</div>
<div class="paragraph">
<p>This rule reports the use of <code>std::enable_if</code>.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>template &lt;typename N, class = typename
  std::enable_if&lt;std::is_integral_v&lt;N&gt; &amp;&amp; std::is_signed_v&lt;N&gt;&gt;::type&gt; // Noncompliant
auto negate(N n) { return -n; }</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>template &lt;class N&gt; requires std::signed_integral&lt;N&gt;
auto negate(N n) { return -n; }</pre>
</div>
</div>
<div class="paragraph">
<p>Or</p>
</div>
<div class="listingblock">
<div class="content">
<pre>template &lt;std::signed_integral N&gt;
auto negate(N n) { return -n; }</pre>
</div>
</div>
<div class="paragraph">
<p>Or</p>
</div>
<div class="listingblock">
<div class="content">
<pre>auto negate(std::signed_integral auto n) { return -n; }</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see">See</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0225r0.html">Why I want Concepts, and why I want them sooner rather than later</a></p>
</div>
<div class="sect2">
<h3 id="_see_also">See Also</h3>
<div class="ulist">
<ul>
<li>
<p>S6017 to see when <code>std::enable_if</code> could be replaced with <code>if constexpr</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>