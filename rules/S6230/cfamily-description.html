<div class="paragraph">
<p>Comparison operators like <code>==</code> or <code>&lt;=&gt;</code>, despite being not hard to write, remain a source of bugs as they need to be updated with every change in the class&#8217;s member list. For instance, if a newly introduced member in the class is not considered by the operation, the issue will only manifest if two instances are identical, except for the newly introduced member. As a consequence, this type of bug is usually hard to spot.</p>
</div>
<div class="paragraph">
<p>C&#43;&#43;20 introduced the ability to define both <code>operator&lt;=&gt;</code> and <code>operator==</code> as defaulted (<code>= default</code>) to indicate that they should consider all members in the order of their declaration. This not only makes code concise but also makes all the comparison operators resilient to the changes to the list of members. Thanks to operator rewriting, all other comparison operations (<code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>=&gt;</code>) can also rely on these robust operators.</p>
</div>
<div class="paragraph">
<p>Furthermore, when <code>operator&lt;=&gt;</code> is defined as defaulted, the compiler will generate a defaulted version of <code>operator==</code> if no other version is declared.</p>
</div>
<div class="paragraph">
<p>This rule raises an issue when the implementation of <code>operator&lt;=&gt;</code> or <code>operator==</code> has an equivalent semantic to the defaulted implementation.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>struct Comparable {
    int x;
    int y;
};

bool operator==(const Comparable&amp; lhs, const Comparable&amp; rhs) { // Noncompliant
    return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y;
}

struct Ordered {
    int x;
    int y;
};

bool operator==(const Ordered&amp; lhs, const Ordered&amp; rhs) { // Noncompliant
    return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y;
}

auto operator&lt;=&gt;(const Ordered&amp; lhs, const Ordered&amp; rhs) { // Noncompliant
    if (res = lhs.x &lt;=&gt; rhs.x; res != 0)
        return x;
    return lhs.y &lt;=&gt; rhs.y;
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>struct Comparable {
    int x;
    int y;

friend bool operator==(const Comparable&amp;, const Comparable&amp;) = default;
};

struct Ordered {
    int x;
    int y;

friend auto operator&lt;=&gt;(const Ordered&amp;, const Ordered&amp;) = default;
};</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see">See</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>S6186 - removing redundant comparison operators</p>
</li>
<li>
<p>S6187 - replacing multiple comparison operators with <code>operator&lt;=&gt;</code></p>
</li>
</ul>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_relates_to_s6186">relates to: S6186</h3>

</div>
<div class="sect2">
<h3 id="_relates_to_s6187">relates to: S6187</h3>

</div>
</div>
</div>