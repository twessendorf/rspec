<div class="paragraph">
<p>The behavior of volatile types in compound expressions that both read and write the same variable (for instance <code>a&#43;&#43;</code> or <code>a+=2</code>, where <code>a</code> is a <code>volatile int</code>) is not well defined, and is deprecated since C&#43;&#43;20.</p>
</div>
<div class="paragraph">
<p>Such expressions should be replaced by explicit operations that only read or write the value.</p>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>void f1(int volatile* p) {
  ++(*p); // Noncompliant
}

void f2(volatile int&amp; in) {
  in += 2; // Noncompliant
}

void f3(volatile int&amp; in) {
  int i = in = 2; // Noncompliant
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>void f1(int volatile* p) {
  auto val = *p;  // One access to read the register
  *p = val + 1; // One access to write to it (and potentially overwrite another change)
}

void f2(volatile int&amp; in) {
  auto val = in;
  in = val + 2;
}

void f3(volatile int&amp; in) {
  in = 2;
  int i = in;
}</pre>
</div>
</div>
</div>
</div>