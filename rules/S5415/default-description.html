<div class="paragraph">
<p>Calling <code>std::move</code> on objects that cannot be moved is suspicious and might hide nasty performance bug.</p>
</div>
<div class="paragraph">
<p>This can happen when calling <code>std::move</code> with const argument or with non-movable types.</p>
</div>
<div class="paragraph">
<p>This can also happen when passing the result of <code>std::move</code> as a const reference argument.  In this case, no object will be moved since the result is in a context where calling the move constructor is not possible. It makes sense to call <code>std::move</code> on a function argument when:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The result of <code>std::move</code> is passed as an r-value reference.</p>
</li>
<li>
<p>The result of <code>std::move</code> is passed by copy.</p>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="_noncompliant_code_example">Noncompliant Code Example</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>struct NonMovable{
  NonMovable() = default;
  NonMovable(NonMovable&amp;) = default;
};

void f(NonMovable s);
void f(std::string s);
void g(const std::string &amp;s);

void test() {
  std::string s="****";
  f(std::move(s));
  g(std::move(s)); // Noncompliant: s is cast back to const l-value reference. s will not be moved.

  const std::string constS="***";
  f(std::move(constS)); // Noncompliant: constS will not be moved.

  NonMovable t;
  f(std::move(t)); // Noncompliant: std::move is useless on non-movable objects like t. Copy constructor is called.
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compliant_solution">Compliant Solution</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>struct Movable{
  Movable() = default;
  Movable(Movable&amp;) = default;
  Movable(Movable&amp;&amp;) = default;
};

void f(Movable);
void f(std::string s);
void g(const std::string &amp;s);

void test() {
  std::string s="****";
  f(std::move(s)); // Compliant:  move constructor is called.
  g(s); // Compliant: no misleading std::move is used.

  Movables t;
  f(std::move(t)); // Compliant: move constructor is called.
}</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see">See</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es56-write-stdmove-only-when-you-need-to-explicitly-move-an-object-to-another-scope">C&#43;&#43; Core Guidelines ES.56</a> - Write "std::move()" only when you need to explicitly move an object to another scope</p>
</li>
</ul>
</div>
<hr/>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_relates_to_s5272">relates to: S5272</h3>

</div>
<div class="sect2">
<h3 id="_relates_to_s5274">relates to: S5274</h3>

</div>
<div class="sect2">
<h3 id="_on_31_jul_2020_002927_loïc_joly_wrote">on 31 Jul 2020, 00:29:27 Loïc Joly wrote:</h3>
<div class="paragraph">
<p>\[~abbas.sabra]: What do you plan to do inside templates? I think I would totally ignore this rule for dependant arguments, because it might be instantiated with types for which it makes sense&#8230;&#8203; (unless for instance if the const is not deduced, but is part of the template)</p>
</div>
</div>
<div class="sect2">
<h3 id="_on_31_jul_2020_004621_abbas_sabra_wrote">on 31 Jul 2020, 00:46:21 Abbas Sabra wrote:</h3>
<div class="paragraph">
<p>\[~loic.joly] I ignore instantiation and I analyze the main template. If an issue can be detected in the main template, it means that calling std::move is going to be useless in all instantiation and should be removed.</p>
</div>
</div>
</div>
</div>